<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <link rel="stylesheet" href="styles.css">
    <script src="js/theme-switcher.js"></script>
    <!-- Using REAL Stockfish C++ engine via backend (not JavaScript!) -->
    <style>
        #chessBoard {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            gap: 0;
            margin: 20px auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 3px solid #8B4513;
        }

        .square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fc97f !important;
        }

        .square.valid-move {
            background-color: #9fdf9f !important;
        }

        .square.ai-move-from {
            background-color: #FFD700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        .square.ai-move-to {
            background-color: #FF6B6B !important;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.8);
        }

        .square:hover {
            opacity: 0.8;
        }

        .captured-pieces {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .captured-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        .captured-section h3 {
            margin-bottom: 10px;
        }

        .pieces {
            font-size: 30px;
        }
    </style>
    <script src="js/chess-timer.js"></script>
    <script src="chess-timer-integration.js"></script>
</head>
<body>
    <div class="container game-container">
        <a href="index.html" class="back-button">‚Üê Back to Games</a>
        
        <div class="game-header">
            <h1>‚ôüÔ∏è Chess</h1>
            <div class="status" id="status">White's Turn</div>
        </div>

        <div class="game-controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()">Undo Move</button>
            <button onclick="flipBoard()">üîÑ Flip Board</button>
            <button onclick="toggleAI()" id="aiToggle">ü§ñ Play vs AI</button>
            <button onclick="toggleAIVsAI()" id="aiVsAiToggle">ü§ñü§ñ AI vs AI</button>
            <button onclick="cyclePieceSet()" id="pieceSetBtn">üé® Pieces: Classic</button>
            <a href="chess-3d.html" style="text-decoration: none;">
                <button>üéÆ 3D Chess</button>
            </a>
            <a href="chess-education.html" style="text-decoration: none;">
                <button>üìö Learn Chess</button>
            </a>
        </div>

        <div class="game-controls" id="aiControls" style="display: none;">
            <label style="color: #fff; margin-right: 10px;">AI Difficulty:</label>
            <select id="aiLevel" onchange="setAIDifficulty()" style="padding: 8px; border-radius: 5px;">
                <option value="1">Level 1 - Beginner</option>
                <option value="3">Level 3 - Novice</option>
                <option value="5">Level 5 - Intermediate</option>
                <option value="8">Level 8 - Advanced</option>
                <option value="10" selected>Level 10 - Strong</option>
                <option value="13">Level 13 - Expert</option>
                <option value="15">Level 15 - Master</option>
                <option value="18">Level 18 - Grandmaster</option>
                <option value="20">Level 20 - Stockfish Full Power!</option>
            </select>
            <span id="aiThinking" style="display: none; color: #FFD700; margin-left: 15px;">
                ü§î AI is thinking...
            </span>
        </div>

        <div class="game-controls" id="aiVsAiControls" style="display: none;">
            <label style="color: #fff; margin-right: 10px;">White AI:</label>
            <select id="whiteAILevel" onchange="setWhiteAIDifficulty()" style="padding: 8px; border-radius: 5px;">
                <option value="1">Level 1 - Beginner</option>
                <option value="5">Level 5 - Intermediate</option>
                <option value="10" selected>Level 10 - Strong</option>
                <option value="15">Level 15 - Master</option>
                <option value="20">Level 20 - Stockfish Full Power!</option>
            </select>
            <label style="color: #fff; margin-left: 20px; margin-right: 10px;">Black AI:</label>
            <select id="blackAILevel" onchange="setBlackAIDifficulty()" style="padding: 8px; border-radius: 5px;">
                <option value="1">Level 1 - Beginner</option>
                <option value="5">Level 5 - Intermediate</option>
                <option value="10" selected>Level 10 - Strong</option>
                <option value="15">Level 15 - Master</option>
                <option value="20">Level 20 - Stockfish Full Power!</option>
            </select>
            <label style="color: #fff; margin-left: 20px; margin-right: 10px;">Move Delay:</label>
            <select id="moveDelay" onchange="setMoveDelay()" style="padding: 8px; border-radius: 5px;">
                <option value="500">0.5s (Fast)</option>
                <option value="1000" selected>1.0s (Normal)</option>
                <option value="2000">2.0s (Slow)</option>
                <option value="3000">3.0s (Very Slow)</option>
            </select>
            <span id="aiVsAiStatus" style="color: #FFD700; margin-left: 15px;">
                ‚è∏Ô∏è Paused - Click to start
            </span>
        </div>

        <div id="chessBoard"></div>

        <div class="captured-pieces">
            <div class="captured-section">
                <h3>Captured by White</h3>
                <div class="pieces" id="whiteCaptured"></div>
            </div>
            <div class="captured-section">
                <h3>Captured by Black</h3>
                <div class="pieces" id="blackCaptured"></div>
            </div>
        </div>
    </div>

    <script>
        const pieces = {
            white: {
                king: '‚ôî', queen: '‚ôï', rook: '‚ôñ', bishop: '‚ôó', knight: '‚ôò', pawn: '‚ôô'
            },
            black: {
                king: '‚ôö', queen: '‚ôõ', rook: '‚ôú', bishop: '‚ôù', knight: '‚ôû', pawn: '‚ôü'
            }
        };

        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let whiteCaptured = [];
        let blackCaptured = [];
        let moveHistory = [];
        let boardFlipped = false;
        let currentPieceSet = 0;
        
        // SVG Chess Piece Paths (High-quality Staunton-style from chess.com/wikipedia)
        const SVG_PIECES = {
            white: {
                king: 'M 22.5,11.63 L 22.5,6 L 25,6 L 25,11.63 C 27.5,12.13 30,14 30,16.5 C 30,17.5 29.5,18.5 28.5,19.5 L 28.5,20 L 30,20 L 30,25 L 28.5,25 L 28.5,26 C 28.5,28 27,29.5 25,29.5 L 25,35 L 22.5,35 L 22.5,29.5 C 20.5,29.5 19,28 19,26 L 19,25 L 17.5,25 L 17.5,20 L 19,20 L 19,19.5 C 18,18.5 17.5,17.5 17.5,16.5 C 17.5,14 20,12.13 22.5,11.63 Z M 22.5,25 L 22.5,22.5 L 25,22.5 L 25,25 Z',
                queen: 'M 9,26 C 17.5,24.5 30,24.5 39,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 Z M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 17,38.5 27,38.5 33,36 C 33,36 33.5,34.5 32,33.5 C 31.5,31 31.5,31.5 32.5,30 C 33.5,28 35,28 35,26 C 27,24.5 17.5,24.5 9,26 Z',
                rook: 'M 9,39 L 9,30 L 12.5,30 L 12.5,34 L 17.5,34 L 17.5,30 L 20,30 L 20,34 L 25,34 L 25,30 L 27.5,30 L 27.5,34 L 32.5,34 L 32.5,30 L 36,30 L 36,39 Z M 9,39 L 9,42 L 36,42 L 36,39 Z M 12,35.5 L 14,35.5 L 14,38.5 L 12,38.5 Z M 16,35.5 L 18,35.5 L 18,38.5 L 16,38.5 Z M 20,35.5 L 22,35.5 L 22,38.5 L 20,38.5 Z M 24,35.5 L 26,35.5 L 26,38.5 L 24,38.5 Z M 28,35.5 L 30,35.5 L 30,38.5 L 28,38.5 Z M 32,35.5 L 34,35.5 L 34,38.5 L 32,38.5 Z',
                bishop: 'M 6,36 C 6,36 21,21 22.5,23.5 C 24,26 27.5,26 27.5,26 C 27.5,26 27.5,19.5 25.5,17.5 C 25.5,17.5 24.5,14.5 24.5,10.5 C 24.5,9.5 24.5,8.5 24.5,7.5 C 24.5,5.5 23.5,5 22.5,5 C 22.5,5 22.5,3.5 22.5,3.5 C 21.5,3.5 20.5,3.5 20.5,3.5 L 20.5,5 C 19.5,5 18.5,5.5 18.5,7.5 L 18.5,10.5 C 18.5,14.5 17.5,17.5 17.5,17.5 C 15.5,19.5 15.5,26 15.5,26 C 15.5,26 19,26 20.5,23.5 C 22,21 37,36 37,36 L 37,39 L 6,39 Z',
                knight: 'M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18 Z M 9.5,25.5 C 9.5,25.5 15,24.5 15,30.5 C 15,36.5 9.5,38.5 9.5,38.5 Z M 11,12.5 C 11,12.5 15.5,12.5 16.5,15.5 C 16.5,15.5 18.5,12.5 22,11.5 C 22,11.5 19,13.5 19,16.5 C 19,19.5 22,18.5 22,18.5 Z',
                pawn: 'M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.53,24.84 18,26.03 C 18,26.66 18,27.33 18,28 L 18,33 L 26,33 L 26,28 L 26,26.03 C 27.47,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 Z'
            },
            black: {
                king: 'M 22.5,11.63 L 22.5,6 L 25,6 L 25,11.63 C 27.5,12.13 30,14 30,16.5 C 30,17.5 29.5,18.5 28.5,19.5 L 28.5,20 L 30,20 L 30,25 L 28.5,25 L 28.5,26 C 28.5,28 27,29.5 25,29.5 L 25,35 L 22.5,35 L 22.5,29.5 C 20.5,29.5 19,28 19,26 L 19,25 L 17.5,25 L 17.5,20 L 19,20 L 19,19.5 C 18,18.5 17.5,17.5 17.5,16.5 C 17.5,14 20,12.13 22.5,11.63 Z M 22.5,25 L 22.5,22.5 L 25,22.5 L 25,25 Z',
                queen: 'M 9,26 C 17.5,24.5 30,24.5 39,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 Z M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 17,38.5 27,38.5 33,36 C 33,36 33.5,34.5 32,33.5 C 31.5,31 31.5,31.5 32.5,30 C 33.5,28 35,28 35,26 C 27,24.5 17.5,24.5 9,26 Z',
                rook: 'M 9,39 L 9,30 L 12.5,30 L 12.5,34 L 17.5,34 L 17.5,30 L 20,30 L 20,34 L 25,34 L 25,30 L 27.5,30 L 27.5,34 L 32.5,34 L 32.5,30 L 36,30 L 36,39 Z M 9,39 L 9,42 L 36,42 L 36,39 Z M 12,35.5 L 14,35.5 L 14,38.5 L 12,38.5 Z M 16,35.5 L 18,35.5 L 18,38.5 L 16,38.5 Z M 20,35.5 L 22,35.5 L 22,38.5 L 20,38.5 Z M 24,35.5 L 26,35.5 L 26,38.5 L 24,38.5 Z M 28,35.5 L 30,35.5 L 30,38.5 L 28,38.5 Z M 32,35.5 L 34,35.5 L 34,38.5 L 32,38.5 Z',
                bishop: 'M 6,36 C 6,36 21,21 22.5,23.5 C 24,26 27.5,26 27.5,26 C 27.5,26 27.5,19.5 25.5,17.5 C 25.5,17.5 24.5,14.5 24.5,10.5 C 24.5,9.5 24.5,8.5 24.5,7.5 C 24.5,5.5 23.5,5 22.5,5 C 22.5,5 22.5,3.5 22.5,3.5 C 21.5,3.5 20.5,3.5 20.5,3.5 L 20.5,5 C 19.5,5 18.5,5.5 18.5,7.5 L 18.5,10.5 C 18.5,14.5 17.5,17.5 17.5,17.5 C 15.5,19.5 15.5,26 15.5,26 C 15.5,26 19,26 20.5,23.5 C 22,21 37,36 37,36 L 37,39 L 6,39 Z',
                knight: 'M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18 Z M 9.5,25.5 C 9.5,25.5 15,24.5 15,30.5 C 15,36.5 9.5,38.5 9.5,38.5 Z M 11,12.5 C 11,12.5 15.5,12.5 16.5,15.5 C 16.5,15.5 18.5,12.5 22,11.5 C 22,11.5 19,13.5 19,16.5 C 19,19.5 22,18.5 22,18.5 Z',
                pawn: 'M 22,9 C 19.79,9 18,10.79 18,13 C 18,13.89 18.29,14.71 18.78,15.38 C 16.83,16.5 15.5,18.59 15.5,21 C 15.5,23.03 16.53,24.84 18,26.03 C 18,26.66 18,27.33 18,28 L 18,33 L 26,33 L 26,28 L 26,26.03 C 27.47,24.84 28.5,23.03 28.5,21 C 28.5,18.59 27.17,16.5 25.22,15.38 C 25.71,14.71 26,13.89 26,13 C 26,10.79 24.21,9 22,9 Z'
            }
        };

        // Multiple piece sets to choose from
        const PIECE_SETS = [
            {
                name: "Classic",
                white: { king: '‚ôî', queen: '‚ôï', rook: '‚ôñ', bishop: '‚ôó', knight: '‚ôò', pawn: '‚ôô' },
                black: { king: '‚ôö', queen: '‚ôõ', rook: '‚ôú', bishop: '‚ôù', knight: '‚ôû', pawn: '‚ôü' }
            },
            {
                name: "Modern",
                white: { king: 'ü§¥', queen: 'üë∏', rook: 'üè∞', bishop: '‚õ™', knight: 'üê¥', pawn: '‚ö™' },
                black: { king: 'ü§¥üèø', queen: 'üë∏üèø', rook: 'üèØ', bishop: '‚õ©Ô∏è', knight: 'üêé', pawn: '‚ö´' }
            },
            {
                name: "Emoji",
                white: { king: 'üëë', queen: 'üíé', rook: 'üèõÔ∏è', bishop: '‚õ™', knight: 'ü¶Ñ', pawn: 'üîπ' },
                black: { king: 'üé©', queen: 'üíç', rook: 'üè∞', bishop: 'üïå', knight: 'ü¶ì', pawn: 'üî∏' }
            },
            {
                name: "SVG",
                type: 'svg'
            }
        ];

        // Create SVG chess piece (using Unicode symbols as scalable SVG text - much better quality)
        function createSVGPiece(color, type) {
            const unicodePieces = {
                white: { king: '‚ôî', queen: '‚ôï', rook: '‚ôñ', bishop: '‚ôó', knight: '‚ôò', pawn: '‚ôô' },
                black: { king: '‚ôö', queen: '‚ôõ', rook: '‚ôú', bishop: '‚ôù', knight: '‚ôû', pawn: '‚ôü' }
            };
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '70');
            svg.setAttribute('height', '70');
            svg.setAttribute('viewBox', '0 0 70 70');
            svg.style.display = 'block';
            svg.style.margin = '0 auto';
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', '35');
            text.setAttribute('y', '50');
            text.setAttribute('font-size', '56');
            text.setAttribute('font-family', 'Arial, sans-serif');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'central');
            
            if (color === 'white') {
                // White pieces: white fill with dark stroke for visibility on light squares
                text.setAttribute('fill', '#ffffff');
                text.setAttribute('stroke', '#333333');
                text.setAttribute('stroke-width', '1.5');
                text.setAttribute('stroke-linejoin', 'round');
                text.style.fontWeight = 'bold';
            } else {
                // Black pieces: black fill
                text.setAttribute('fill', '#000000');
                text.style.fontWeight = 'bold';
            }
            
            text.textContent = unicodePieces[color][type];
            
            svg.appendChild(text);
            return svg;
        }

        function initBoard() {
            board = [
                [{type: 'rook', color: 'black'}, {type: 'knight', color: 'black'}, {type: 'bishop', color: 'black'}, {type: 'queen', color: 'black'}, {type: 'king', color: 'black'}, {type: 'bishop', color: 'black'}, {type: 'knight', color: 'black'}, {type: 'rook', color: 'black'}],
                Array(8).fill(null).map(() => ({type: 'pawn', color: 'black'})),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null),
                Array(8).fill(null).map(() => ({type: 'pawn', color: 'white'})),
                [{type: 'rook', color: 'white'}, {type: 'knight', color: 'white'}, {type: 'bishop', color: 'white'}, {type: 'queen', color: 'white'}, {type: 'king', color: 'white'}, {type: 'bishop', color: 'white'}, {type: 'knight', color: 'white'}, {type: 'rook', color: 'white'}]
            ];
        }

        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            if (!boardElement) {
                console.error('chessBoard element not found');
                return;
            }
            
            if (!board || board.length === 0) {
                console.error('Board not initialized');
                initBoard();
            }
            
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const displayRow = boardFlipped ? 7 - row : row;
                    const displayCol = boardFlipped ? 7 - col : col;
                    
                    const square = document.createElement('div');
                    square.className = `square ${(displayRow + displayCol) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    const piece = board[row] && board[row][col];
                    if (piece) {
                        const pieceSet = PIECE_SETS[currentPieceSet];
                        if (pieceSet) {
                            if (pieceSet.type === 'svg') {
                                const svgPiece = createSVGPiece(piece.color, piece.type);
                                square.appendChild(svgPiece);
                            } else {
                                square.textContent = pieceSet[piece.color][piece.type];
                            }
                        }
                    }

                    square.onclick = () => handleSquareClick(row, col);
                    boardElement.appendChild(square);
                }
            }

            updateStatus();
            updateCapturedPieces();
        }
        
        function flipBoard() {
            boardFlipped = !boardFlipped;
            renderBoard();
            console.log('Board flipped:', boardFlipped ? 'Black perspective' : 'White perspective');
        }

        function handleSquareClick(row, col) {
            if (selectedSquare) {
                const [selectedRow, selectedCol] = selectedSquare;
                if (isValidMove(selectedRow, selectedCol, row, col)) {
                    makeMove(selectedRow, selectedCol, row, col);
                }
                clearSelection();
            } else {
                const piece = board[row][col];
                if (piece && piece.color === currentPlayer) {
                    selectedSquare = [row, col];
                    highlightValidMoves(row, col);
                }
            }
        }

        function highlightValidMoves(row, col) {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                if (r === row && c === col) {
                    square.classList.add('selected');
                } else if (isValidMove(row, col, r, c)) {
                    square.classList.add('valid-move');
                }
            });
        }

        function clearSelection() {
            selectedSquare = null;
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'valid-move');
            });
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow && fromCol === toCol) return false;

            const piece = board[fromRow][fromCol];
            const target = board[toRow][toCol];

            if (!piece) return false;
            if (target && target.color === piece.color) return false;

            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const absRowDiff = Math.abs(rowDiff);
            const absColDiff = Math.abs(colDiff);

            switch (piece.type) {
                case 'pawn':
                    const direction = piece.color === 'white' ? -1 : 1;
                    const startRow = piece.color === 'white' ? 6 : 1;
                    
                    if (colDiff === 0 && !target) {
                        if (rowDiff === direction) return true;
                        if (fromRow === startRow && rowDiff === 2 * direction && !board[fromRow + direction][fromCol]) return true;
                    }
                    if (absColDiff === 1 && rowDiff === direction && target) return true;
                    return false;

                case 'rook':
                    if (rowDiff === 0 || colDiff === 0) {
                        return !isPathBlocked(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'knight':
                    return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);

                case 'bishop':
                    if (absRowDiff === absColDiff) {
                        return !isPathBlocked(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'queen':
                    if (rowDiff === 0 || colDiff === 0 || absRowDiff === absColDiff) {
                        return !isPathBlocked(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'king':
                    return absRowDiff <= 1 && absColDiff <= 1;
            }

            return false;
        }

        function isPathBlocked(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return true;
                currentRow += rowStep;
                currentCol += colStep;
            }

            return false;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];

            moveHistory.push({
                from: {row: fromRow, col: fromCol},
                to: {row: toRow, col: toCol},
                piece: piece,
                captured: captured
            });

            if (captured) {
                if (currentPlayer === 'white') {
                    whiteCaptured.push(captured);
                } else {
                    blackCaptured.push(captured);
                }
            }

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;

            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // Update timer
            if (typeof window.switchTimer === 'function') {
                window.switchTimer(currentPlayer);
            }
            
            renderBoard();
        }

        function undoMove() {
            if (moveHistory.length === 0) return;

            const lastMove = moveHistory.pop();
            board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
            board[lastMove.to.row][lastMove.to.col] = lastMove.captured;

            if (lastMove.captured) {
                if (currentPlayer === 'black') {
                    whiteCaptured.pop();
                } else {
                    blackCaptured.pop();
                }
            }

            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            renderBoard();
        }

        function updateStatus() {
            const status = document.getElementById('status');
            status.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s Turn`;
        }

        function updateCapturedPieces() {
            const pieceSet = PIECE_SETS[currentPieceSet];
            const whiteEl = document.getElementById('whiteCaptured');
            const blackEl = document.getElementById('blackCaptured');
            
            whiteEl.innerHTML = '';
            blackEl.innerHTML = '';
            
            if (pieceSet.type === 'svg') {
                whiteCaptured.forEach(p => {
                    const svg = createSVGPiece(p.color, p.type);
                    svg.setAttribute('width', '28');
                    svg.setAttribute('height', '28');
                    svg.setAttribute('viewBox', '0 0 70 70');
                    // Update text element for smaller size
                    const text = svg.querySelector('text');
                    if (text) {
                        text.setAttribute('font-size', '22');
                        text.setAttribute('x', '35');
                        text.setAttribute('y', '50');
                        if (p.color === 'white') {
                            text.setAttribute('stroke-width', '0.8');
                        }
                    }
                    svg.style.display = 'inline-block';
                    svg.style.margin = '0 2px';
                    svg.style.verticalAlign = 'middle';
                    whiteEl.appendChild(svg);
                });
                blackCaptured.forEach(p => {
                    const svg = createSVGPiece(p.color, p.type);
                    svg.setAttribute('width', '28');
                    svg.setAttribute('height', '28');
                    svg.setAttribute('viewBox', '0 0 70 70');
                    // Update text element for smaller size
                    const text = svg.querySelector('text');
                    if (text) {
                        text.setAttribute('font-size', '22');
                        text.setAttribute('x', '35');
                        text.setAttribute('y', '50');
                    }
                    svg.style.display = 'inline-block';
                    svg.style.margin = '0 2px';
                    svg.style.verticalAlign = 'middle';
                    blackEl.appendChild(svg);
                });
            } else {
                whiteEl.textContent = whiteCaptured.map(p => pieceSet[p.color][p.type]).join(' ');
                blackEl.textContent = blackCaptured.map(p => pieceSet[p.color][p.type]).join(' ');
            }
        }
        
        function cyclePieceSet() {
            currentPieceSet = (currentPieceSet + 1) % PIECE_SETS.length;
            const setName = PIECE_SETS[currentPieceSet].name;
            document.getElementById('pieceSetBtn').textContent = `üé® Pieces: ${setName}`;
            renderBoard();
            updateCapturedPieces();
        }

        function newGame() {
            initBoard();
            currentPlayer = 'white';
            whiteCaptured = [];
            blackCaptured = [];
            moveHistory = [];
            selectedSquare = null;
            
            // Start timer for white if enabled
            if (typeof window.startTimer === 'function') {
                window.startTimer('white');
            }
            
            renderBoard();
        }
        
        // Make newGame globally accessible for timer integration
        window.newGame = newGame;

        // AI Integration with Stockfish
        let aiEnabled = false;
        let aiVsAiMode = false;
        let aiVsAiPaused = true;
        let stockfish = null;
        let aiLevel = 10;
        let whiteAILevel = 10;
        let blackAILevel = 10;
        let moveDelay = 1000; // Delay between AI moves in AI vs AI mode
        let aiThinkingNow = false;

        function toggleAI() {
            // If AI vs AI is active, disable it first
            if (aiVsAiMode) {
                toggleAIVsAI();
            }
            
            aiEnabled = !aiEnabled;
            const btn = document.getElementById('aiToggle');
            const controls = document.getElementById('aiControls');
            
            if (aiEnabled) {
                btn.textContent = 'üë§ Play vs Human';
                btn.style.background = 'rgba(76, 175, 80, 0.3)';
                controls.style.display = 'block';
                initializeAI();
            } else {
                btn.textContent = 'ü§ñ Play vs AI';
                btn.style.background = '';
                controls.style.display = 'none';
            }
        }

        function toggleAIVsAI() {
            // If regular AI is active, disable it first
            if (aiEnabled) {
                toggleAI();
            }
            
            aiVsAiMode = !aiVsAiMode;
            const btn = document.getElementById('aiVsAiToggle');
            const controls = document.getElementById('aiVsAiControls');
            const statusEl = document.getElementById('aiVsAiStatus');
            
            if (aiVsAiMode) {
                btn.textContent = 'üë§ Human vs Human';
                btn.style.background = 'rgba(255, 152, 0, 0.3)';
                controls.style.display = 'block';
                aiVsAiPaused = false;
                statusEl.textContent = '‚ñ∂Ô∏è Running - AI vs AI in progress';
                initializeAI().then(() => {
                    // Start the AI vs AI game
                    if (currentPlayer === 'white') {
                        setTimeout(() => getAIMoveForPlayer('white'), 500);
                    } else {
                        setTimeout(() => getAIMoveForPlayer('black'), 500);
                    }
                });
            } else {
                btn.textContent = 'ü§ñü§ñ AI vs AI';
                btn.style.background = '';
                controls.style.display = 'none';
                aiVsAiPaused = true;
            }
        }

        function setWhiteAIDifficulty() {
            whiteAILevel = parseInt(document.getElementById('whiteAILevel').value);
            console.log('White AI difficulty set to', whiteAILevel);
        }

        function setBlackAIDifficulty() {
            blackAILevel = parseInt(document.getElementById('blackAILevel').value);
            console.log('Black AI difficulty set to', blackAILevel);
        }

        function setMoveDelay() {
            moveDelay = parseInt(document.getElementById('moveDelay').value);
            console.log('Move delay set to', moveDelay, 'ms');
        }

        async function initializeAI() {
            if (stockfish) {
                console.log('Real Stockfish backend already connected');
                return;
            }
            
            try {
                console.log('Connecting to REAL Stockfish backend...');
                
                // Check if backend is running
                const response = await fetch('http://localhost:9543/api/status');
                const status = await response.json();
                
                console.log('Backend status:', status);
                
                if (status.ready) {
                    stockfish = true; // Mark as connected
                    console.log('‚úÖ Connected to:', status.engine);
                    console.log('‚úÖ ELO:', status.elo);
                    alert(`Connected to ${status.engine}\nELO: ${status.elo}\nThis is the REAL Stockfish!`);
                } else {
                    throw new Error('Backend not ready');
                }
                
            } catch (error) {
                console.error('Failed to connect to Stockfish backend:', error);
                alert('‚ùå Real Stockfish backend not running!\n\nPlease start it first:\ncd D:\\Dev\\repos\\games-app\npython stockfish-server.py');
                stockfish = null;
            }
        }

        function setAIDifficulty() {
            aiLevel = parseInt(document.getElementById('aiLevel').value);
            console.log('AI difficulty set to', aiLevel);
        }

        // Override makeMove to trigger AI
        const originalMakeMove = makeMove;
        makeMove = function(fromRow, fromCol, toRow, toCol) {
            originalMakeMove(fromRow, fromCol, toRow, toCol);
            
            // If AI vs AI mode, trigger next AI move
            if (aiVsAiMode && !aiVsAiPaused && stockfish) {
                setTimeout(() => {
                    getAIMoveForPlayer(currentPlayer);
                }, moveDelay);
            }
            // If regular AI enabled and it's black's turn, get AI move
            else if (aiEnabled && currentPlayer === 'black' && stockfish) {
                setTimeout(getAIMove, 500);
            }
        };

        async function getAIMove() {
            // Use black AI level for regular AI mode
            return getAIMoveForPlayer('black', aiLevel);
        }

        async function getAIMoveForPlayer(player, customLevel = null) {
            if (aiThinkingNow) {
                console.log('AI already thinking, skipping...');
                return;
            }
            
            if (!stockfish) {
                console.error('Stockfish backend not connected!');
                if (!aiVsAiMode) {
                    alert('Real Stockfish not running! Start: python stockfish-server.py');
                }
                return;
            }

            // Check if game is over
            // Simple game over check - if status indicates game over, stop AI
            const gameStatusEl = document.getElementById('status');
            if (gameStatusEl && (gameStatusEl.textContent.includes('Checkmate') || 
                             gameStatusEl.textContent.includes('Stalemate') ||
                             gameStatusEl.textContent.includes('Game Over'))) {
                console.log('Game over detected, stopping AI moves');
                if (aiVsAiMode) {
                    const aiStatusEl = document.getElementById('aiVsAiStatus');
                    if (aiStatusEl) {
                        aiStatusEl.textContent = 'üèÅ Game Over';
                    }
                }
                return;
            }
            
            aiThinkingNow = true;
            const thinking = document.getElementById('aiThinking');
            const statusEl = document.getElementById('aiVsAiStatus');
            
            if (aiVsAiMode) {
                statusEl.textContent = `ü§î ${player.toUpperCase()} AI thinking...`;
            } else {
                thinking.style.display = 'inline';
            }
            
            try {
                // Generate FEN from current board
                const fen = boardToFEN();
                console.log(`ü§ñ Requesting move from REAL Stockfish for ${player}...`);
                console.log('Position FEN:', fen);
                
                // Configure based on difficulty
                let skillLevel;
                if (customLevel !== null) {
                    skillLevel = customLevel;
                } else {
                    skillLevel = player === 'white' ? whiteAILevel : blackAILevel;
                }
                const depth = Math.min(20, Math.floor(skillLevel / 2) + 5); // 5-20 depth
                const moveTime = 100 + (skillLevel * 100); // 200ms - 2100ms
                
                console.log(`Settings: Player=${player}, Skill=${skillLevel}, Depth=${depth}, Time=${moveTime}ms`);
                
                // Call REAL Stockfish backend
                const response = await fetch('http://localhost:9543/api/move', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        fen: fen,
                        skill: skillLevel,
                        depth: depth,
                        movetime: moveTime
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.move) {
                    console.log(`‚úÖ Stockfish says for ${player}:`, result.move);
                    console.log('Engine:', result.engine);
                    executeStockfishMove(result.move, player);
                } else {
                    throw new Error(result.error || 'No move returned');
                }
                
            } catch (error) {
                console.error('‚ùå AI error:', error);
                if (!aiVsAiMode) {
                    alert('AI Error: ' + error.message + '\n\nMake sure backend is running:\npython stockfish-server.py');
                }
                aiThinkingNow = false;
                thinking.style.display = 'none';
                if (aiVsAiMode) {
                    statusEl.textContent = '‚ùå AI Error - Check backend';
                }
            }
        }
        
        function boardToFEN() {
            let fen = '';
            
            // Board position
            for (let row = 0; row < 8; row++) {
                let emptyCount = 0;
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (!piece) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        const pieceChar = getPieceFEN(piece);
                        fen += pieceChar;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (row < 7) fen += '/';
            }
            
            // Active color
            fen += ' ' + (currentPlayer === 'white' ? 'w' : 'b');
            
            // Castling rights (simplified - assume all available at start)
            fen += ' KQkq';
            
            // En passant target square (simplified)
            fen += ' -';
            
            // Halfmove clock (simplified)
            fen += ' 0';
            
            // Fullmove number
            fen += ' ' + Math.floor(moveHistory.length / 2 + 1);
            
            return fen;
        }
        
        function getPieceFEN(piece) {
            const pieceMap = {
                'pawn': 'p', 'knight': 'n', 'bishop': 'b',
                'rook': 'r', 'queen': 'q', 'king': 'k'
            };
            const char = pieceMap[piece.type];
            return piece.color === 'white' ? char.toUpperCase() : char;
        }
        
        function highlightAIMove(fromRow, fromCol, toRow, toCol) {
            // Clear any existing AI move highlights
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('ai-move-from', 'ai-move-to');
            });
            
            // Find and highlight the squares
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                
                // Account for board flipping
                const displayRow = boardFlipped ? 7 - row : row;
                const displayCol = boardFlipped ? 7 - col : col;
                
                if (row === fromRow && col === fromCol) {
                    square.classList.add('ai-move-from');
                } else if (row === toRow && col === toCol) {
                    square.classList.add('ai-move-to');
                }
            });
        }

        function clearAIMoveHighlight() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('ai-move-from', 'ai-move-to');
            });
        }

        function executeStockfishMove(uciMove, player = null) {
            // Parse UCI move (e.g., "e2e4", "e7e8q")
            if (uciMove.length < 4) {
                aiThinkingNow = false;
                document.getElementById('aiThinking').style.display = 'none';
                const statusEl = document.getElementById('aiVsAiStatus');
                if (aiVsAiMode && statusEl) {
                    statusEl.textContent = '‚ùå Invalid move';
                }
                return;
            }
            
            const fromCol = uciMove.charCodeAt(0) - 97; // a=0, b=1, etc.
            const fromRow = 8 - parseInt(uciMove[1]);
            const toCol = uciMove.charCodeAt(2) - 97;
            const toRow = 8 - parseInt(uciMove[3]);
            
            console.log(`Stockfish move: ${uciMove} => (${fromRow},${fromCol}) to (${toRow},${toCol})`);
            
            // Highlight the AI move before executing
            highlightAIMove(fromRow, fromCol, toRow, toCol);
            
            // Temporarily disable AI trigger to prevent infinite loop
            const wasAIEnabled = aiEnabled;
            const wasAiVsAiMode = aiVsAiMode;
            aiEnabled = false;
            aiVsAiMode = false;
            
            // Execute the move
            if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                // Small delay to show the highlight before moving
                setTimeout(() => {
                    originalMakeMove(fromRow, fromCol, toRow, toCol);
                    console.log('‚úÖ Stockfish move executed successfully');
                    
                    // Keep highlight for a moment after move
                    setTimeout(() => {
                        clearAIMoveHighlight();
                    }, 300);
                    
                    // Play move sound
                    playMoveSound();
                    
                    // If AI vs AI mode, trigger next player's move after delay
                    if (wasAiVsAiMode && !aiVsAiPaused) {
                        const statusEl = document.getElementById('aiVsAiStatus');
                        if (statusEl) {
                            statusEl.textContent = `‚ñ∂Ô∏è ${currentPlayer.toUpperCase()}'s turn next...`;
                        }
                        // The makeMove override will handle triggering the next AI move
                    }
                    
                    // Re-enable AI and reset flags
                    aiEnabled = wasAIEnabled;
                    aiVsAiMode = wasAiVsAiMode;
                    aiThinkingNow = false;
                    document.getElementById('aiThinking').style.display = 'none';
                }, 100);
            } else {
                console.error('Invalid Stockfish move:', uciMove);
                clearAIMoveHighlight();
                const statusEl = document.getElementById('aiVsAiStatus');
                if (wasAiVsAiMode && statusEl) {
                    statusEl.textContent = '‚ùå Invalid move - Game may be over';
                }
                // Re-enable AI and reset flags
                aiEnabled = wasAIEnabled;
                aiVsAiMode = wasAiVsAiMode;
                aiThinkingNow = false;
                document.getElementById('aiThinking').style.display = 'none';
            }
        }
        
        function playMoveSound() {
            // Create a simple beep sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Configure sound (pleasant "click" tone)
            oscillator.frequency.value = 800; // Hz
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Initialize game
        newGame();
    </script>
</body>
</html>


